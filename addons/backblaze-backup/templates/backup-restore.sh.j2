#!/bin/bash
# Backup Restore Script
# Restores files from Backblaze B2 backup

set -euo pipefail

# Configuration
SCRIPT_NAME="$(basename "$0")"
LOG_FILE="{{ backup_log_path }}/backup-restore.log"
CONFIG_FILE="{{ backup_config_path }}/config.yml"
RCLONE_REMOTE="{{ rclone_config_name }}:{{ rclone_remote_name }}"
STAGING_PATH="{{ backup_staging_path }}"

# Logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$SCRIPT_NAME] $1" | tee -a "$LOG_FILE"
}

error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$SCRIPT_NAME] ERROR: $1" | tee -a "$LOG_FILE" >&2
    exit 1
}

# Show usage
show_usage() {
    echo "Usage: $0 [OPTIONS] <backup_name> <restore_path>"
    echo ""
    echo "Options:"
    echo "  -l, --list     List available backups"
    echo "  -d, --dry-run  Show what would be restored without actually restoring"
    echo "  -h, --help     Show this help"
    echo ""
    echo "Examples:"
    echo "  $0 --list"
    echo "  $0 srv /tmp/restore"
    echo "  $0 --dry-run srv /tmp/restore"
    echo ""
    echo "Available backup names:"
    echo "  srv      - Restore /srv directory"
    echo "  caddy    - Restore /etc/caddy directory"
}

# List available backups
list_backups() {
    log "Listing available backups"
    
    echo "Available backups in $RCLONE_REMOTE:"
    rclone lsd "$RCLONE_REMOTE" 2>/dev/null | while read -r _ date time name; do
        if [[ -n "$name" ]]; then
            local size
            size=$(rclone size "$RCLONE_REMOTE/$name" --json 2>/dev/null | jq -r '.bytes // 0' || echo "0")
            printf "  %-20s %s bytes\n" "$name" "$size"
        fi
    done
}

# Validate backup name
validate_backup_name() {
    local backup_name="$1"
    
    case "$backup_name" in
        "srv"|"caddy")
            return 0
            ;;
        *)
            error "Invalid backup name: $backup_name"
            ;;
    esac
}

# Validate restore path
validate_restore_path() {
    local restore_path="$1"
    
    # Check if parent directory exists
    local parent_dir
    parent_dir="$(dirname "$restore_path")"
    
    if [[ ! -d "$parent_dir" ]]; then
        error "Parent directory does not exist: $parent_dir"
    fi
    
    # Check if restore path exists and is not empty
    if [[ -d "$restore_path" && -n "$(ls -A "$restore_path" 2>/dev/null)" ]]; then
        error "Restore path exists and is not empty: $restore_path"
        echo "Use a different path or clear the directory first"
    fi
}

# Perform restore
perform_restore() {
    local backup_name="$1"
    local restore_path="$2"
    local dry_run="${3:-false}"
    
    local remote_path="$RCLONE_REMOTE/$backup_name"
    
    # Check if backup exists
    if ! rclone lsd "$remote_path" &>/dev/null; then
        error "Backup not found: $backup_name"
    fi
    
    # Create restore directory
    if [[ "$dry_run" != "true" ]]; then
        mkdir -p "$restore_path"
    fi
    
    log "Starting restore: $backup_name -> $restore_path"
    if [[ "$dry_run" == "true" ]]; then
        log "DRY RUN: No files will be actually restored"
    fi
    
    # Build rclone command
    local rclone_cmd="rclone sync"
    
    if [[ "$dry_run" == "true" ]]; then
        rclone_cmd="$rclone_cmd --dry-run"
    fi
    
    rclone_cmd="$rclone_cmd --progress --stats-one-line --stats 30s"
    rclone_cmd="$rclone_cmd $remote_path $restore_path"
    
    # Perform restore
    if $rclone_cmd 2>&1 | tee -a "$LOG_FILE"; then
        if [[ "$dry_run" != "true" ]]; then
            log "Restore completed successfully"
            
            # Show restore summary
            local file_count
            file_count=$(find "$restore_path" -type f | wc -l)
            local total_size
            total_size=$(du -sh "$restore_path" | cut -f1)
            
            log "Restore summary:"
            log "  Files restored: $file_count"
            log "  Total size: $total_size"
            log "  Destination: $restore_path"
        else
            log "Dry run completed"
        fi
    else
        error "Restore failed"
    fi
}

# Verify restore
verify_restore() {
    local restore_path="$1"
    
    if [[ ! -d "$restore_path" ]]; then
        error "Restore path does not exist: $restore_path"
    fi
    
    local file_count
    file_count=$(find "$restore_path" -type f | wc -l)
    local total_size
    total_size=$(du -sh "$restore_path" | cut -f1)
    
    log "Restore verification:"
    log "  Files: $file_count"
    log "  Size: $total_size"
    log "  Path: $restore_path"
    
    if [[ $file_count -eq 0 ]]; then
        log "WARNING: No files found in restore directory"
    fi
}

# Main execution
main() {
    local backup_name=""
    local restore_path=""
    local dry_run=false
    local list_only=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -l|--list)
                list_only=true
                shift
                ;;
            -d|--dry-run)
                dry_run=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                if [[ -z "$backup_name" ]]; then
                    backup_name="$1"
                elif [[ -z "$restore_path" ]]; then
                    restore_path="$1"
                else
                    error "Too many arguments"
                fi
                shift
                ;;
        esac
    done
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root"
    fi
    
    # Check dependencies
    if ! command -v rclone &> /dev/null; then
        error "rclone not found"
    fi
    
    # Check rclone configuration
    if ! rclone config show {{ rclone_config_name }} &>/dev/null; then
        error "rclone remote '{{ rclone_config_name }}' not configured"
    fi
    
    # Handle list option
    if [[ "$list_only" == "true" ]]; then
        list_backups
        exit 0
    fi
    
    # Validate arguments
    if [[ -z "$backup_name" || -z "$restore_path" ]]; then
        error "Both backup name and restore path are required"
    fi
    
    validate_backup_name "$backup_name"
    validate_restore_path "$restore_path"
    
    # Perform restore
    perform_restore "$backup_name" "$restore_path" "$dry_run"
    
    # Verify restore (only for actual restores)
    if [[ "$dry_run" != "true" ]]; then
        verify_restore "$restore_path"
    fi
    
    log "Restore process completed"
}

# Run main function
main "$@"
