#!/bin/bash
# Immich Backup Script

set -euo pipefail

# Configuration
SCRIPT_NAME="$(basename "$0")"
IMMICH_DATA_PATH="{{ immich_data_path }}"
BACKUP_PATH="{{ immich_backup_path }}"
BACKUP_RETENTION_DAYS=30
DATE_FORMAT=$(date +%Y%m%d-%H%M%S)
BACKUP_NAME="immich-backup-$DATE_FORMAT"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/backup.log"
}

log_success() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/backup.log"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/backup.log"
}

log_error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/backup.log"
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    if ! command -v docker &> /dev/null; then
        missing+=("docker")
    fi
    
    if ! command -v tar &> /dev/null; then
        missing+=("tar")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        exit 1
    fi
}

# Check if Immich is running
check_immich_status() {
    if ! docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" ps --format json | jq -r '.[] | select(.State == "running") | .Service' | grep -q "immich-server"; then
        log_warning "Immich server is not running"
        return 1
    fi
    return 0
}

# Create backup directory
create_backup_dir() {
    local backup_dir="$BACKUP_PATH/$BACKUP_NAME"
    mkdir -p "$backup_dir"
    echo "$backup_dir"
}

# Backup database
backup_database() {
    local backup_dir="$1"
    local db_backup_file="$backup_dir/database.sql"
    
    log "Backing up database..."
    
    # Run database backup
    if docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database pg_dump -U {{ immich_db_user }} {{ immich_db_name }} > "$db_backup_file"; then
        log_success "Database backup completed"
        
        # Compress database backup
        gzip "$db_backup_file"
        log_success "Database backup compressed"
    else
        log_error "Database backup failed"
        return 1
    fi
}

# Backup application data
backup_app_data() {
    local backup_dir="$1"
    
    log "Backing up application data..."
    
    local data_paths=(
        "{{ immich_upload_path }}"
        "{{ immich_library_path }}"
        "{{ immich_thumb_path }}"
        "{{ immich_profile_path }}"
    )
    
    for path in "${data_paths[@]}"; do
        if [[ -d "$path" ]]; then
            local path_name
            path_name=$(basename "$path")
            local tar_file="$backup_dir/$path_name.tar.gz"
            
            log "Backing up $path_name..."
            
            if tar -czf "$tar_file" -C "$(dirname "$path")" "$(basename "$path")"; then
                log_success "$path_name backup completed"
            else
                log_error "$path_name backup failed"
                return 1
            fi
        else
            log_warning "Path not found: $path"
        fi
    done
}

# Backup configuration files
backup_config() {
    local backup_dir="$1"
    
    log "Backing up configuration..."
    
    local config_backup_file="$backup_dir/config.tar.gz"
    
    if tar -czf "$config_backup_file" -C "$IMMICH_DATA_PATH" \
        docker-compose.yml \
        .env \
        2>/dev/null; then
        log_success "Configuration backup completed"
    else
        log_warning "Configuration backup failed (some files may not exist)"
    fi
}

# Create backup metadata
create_metadata() {
    local backup_dir="$1"
    local metadata_file="$backup_dir/metadata.json"
    
    log "Creating backup metadata..."
    
    cat > "$metadata_file" << EOF
{
    "backup_name": "$BACKUP_NAME",
    "created_at": "$(date -Iseconds)",
    "immich_version": "$(docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" config | grep 'image: ghcr.io/immich-app/immich-server' | cut -d: -f3 || echo 'unknown')",
    "backup_type": "full",
    "database": {
        "name": "{{ immich_db_name }}",
        "user": "{{ immich_db_user }}"
    },
    "data_paths": {
        "upload": "{{ immich_upload_path }}",
        "library": "{{ immich_library_path }}",
        "thumbs": "{{ immich_thumb_path }}",
        "profile": "{{ immich_profile_path }}"
    },
    "system_info": {
        "hostname": "$(hostname)",
        "kernel": "$(uname -r)",
        "docker_version": "$(docker --version | cut -d' ' -f3 | sed 's/,//')"
    }
}
EOF
    
    log_success "Metadata created"
}

# Verify backup
verify_backup() {
    local backup_dir="$1"
    
    log "Verifying backup..."
    
    local required_files=(
        "database.sql.gz"
        "config.tar.gz"
        "metadata.json"
    )
    
    local missing_files=0
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$backup_dir/$file" ]]; then
            log_error "Missing required file: $file"
            ((missing_files++))
        fi
    done
    
    # Check data backups
    local data_files=(
        "uploads.tar.gz"
        "library.tar.gz"
        "thumbs.tar.gz"
        "profile.tar.gz"
    )
    
    for file in "${data_files[@]}"; do
        if [[ -f "$backup_dir/$file" ]]; then
            local size
            size=$(stat -f%z "$backup_dir/$file" 2>/dev/null || stat -c%s "$backup_dir/$file" 2>/dev/null || echo "0")
            if [[ $size -eq 0 ]]; then
                log_warning "Empty backup file: $file"
            fi
        fi
    done
    
    if [[ $missing_files -eq 0 ]]; then
        log_success "Backup verification passed"
        return 0
    else
        log_error "Backup verification failed: $missing_files missing files"
        return 1
    fi
}

# Cleanup old backups
cleanup_old_backups() {
    log "Cleaning up old backups (older than $BACKUP_RETENTION_DAYS days)..."
    
    local deleted_count=0
    while IFS= read -r -d '' backup_dir; do
        if [[ -d "$backup_dir" ]]; then
            local dir_date
            dir_date=$(basename "$backup_dir" | grep -o '[0-9]\{8\}-[0-9]\{6\}' || echo "")
            
            if [[ -n "$dir_date" ]]; then
                local backup_date
                backup_date=$(date -d "${dir_date:0:8} ${dir_date:9:2}:${dir_date:11:2}:${dir_date:13:2}" +%s 2>/dev/null || echo "0")
                local cutoff_date
                cutoff_date=$(date -d "$BACKUP_RETENTION_DAYS days ago" +%s)
                
                if [[ $backup_date -lt $cutoff_date ]]; then
                    log "Deleting old backup: $(basename "$backup_dir")"
                    rm -rf "$backup_dir"
                    ((deleted_count++))
                fi
            fi
        fi
    done < <(find "$BACKUP_PATH" -maxdepth 1 -type d -name "immich-backup-*" -print0)
    
    log_success "Deleted $deleted_count old backups"
}

# Show backup summary
show_summary() {
    local backup_dir="$1"
    
    local total_size
    total_size=$(du -sh "$backup_dir" | cut -f1)
    
    log ""
    log_success "Backup completed successfully"
    log "Backup location: $backup_dir"
    log "Total size: $total_size"
    log "Backup name: $BACKUP_NAME"
    
    # List backup contents
    log "Backup contents:"
    find "$backup_dir" -type f -exec basename {} \; | sort | while read -r file; do
        local size
        size=$(du -h "$backup_dir/$file" | cut -f1)
        log "  $file ($size)"
    done
}

# Show usage
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help          Show this help"
    echo "  -c, --check         Check backup status"
    echo "  -l, --list         List available backups"
    echo "  -r, --restore NAME Restore from backup"
    echo "  --cleanup-only      Only cleanup old backups"
    echo ""
    echo "Environment:"
    echo "  IMMICH_DATA_PATH: $IMMICH_DATA_PATH"
    echo "  BACKUP_PATH: $BACKUP_PATH"
}

# List available backups
list_backups() {
    log "Available backups:"
    
    if [[ ! -d "$BACKUP_PATH" ]]; then
        log "No backup directory found"
        return 1
    fi
    
    find "$BACKUP_PATH" -maxdepth 1 -type d -name "immich-backup-*" -exec basename {} \; | sort | while read -r backup; do
        local backup_dir="$BACKUP_PATH/$backup"
        local size
        size=$(du -sh "$backup_dir" 2>/dev/null | cut -f1 || echo "unknown")
        local date_str
        date_str=$(echo "$backup" | grep -o '[0-9]\{8\}-[0-9]\{6\}' || echo "unknown")
        
        if [[ -n "$date_str" && "$date_str" != "unknown" ]]; then
            local formatted_date
            formatted_date=$(date -d "${date_str:0:8} ${date_str:9:2}:${date_str:11:2}:${date_str:13:2}" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "$date_str")
            printf "  %-25s %10s  %s\n" "$backup" "$size" "$formatted_date"
        else
            printf "  %-25s %10s  %s\n" "$backup" "$size" "unknown date"
        fi
    done
}

# Main execution
main() {
    local check_only=false
    local list_only=false
    local restore_name=""
    local cleanup_only=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -c|--check)
                check_only=true
                shift
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -r|--restore)
                restore_name="$2"
                shift 2
                ;;
            --cleanup-only)
                cleanup_only=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root"
        exit 1
    fi
    
    # Check dependencies
    check_dependencies
    
    # Create backup directory
    mkdir -p "$BACKUP_PATH"
    
    # Handle different modes
    if [[ "$list_only" == "true" ]]; then
        list_backups
        exit 0
    fi
    
    if [[ "$check_only" == "true" ]]; then
        check_immich_status
        exit $?
    fi
    
    if [[ "$cleanup_only" == "true" ]]; then
        cleanup_old_backups
        exit 0
    fi
    
    if [[ -n "$restore_name" ]]; then
        log_error "Restore functionality not implemented in this script"
        log_info "Use immich-restore script for restoration"
        exit 1
    fi
    
    # Main backup process
    log "Starting Immich backup process"
    
    # Check Immich status
    local immich_running=false
    if check_immich_status; then
        immich_running=true
        log "Immich is running"
    else
        log_warning "Immich is not running"
    fi
    
    # Create backup directory
    local backup_dir
    backup_dir=$(create_backup_dir)
    
    # Perform backup
    if backup_database "$backup_dir" && \
       backup_app_data "$backup_dir" && \
       backup_config "$backup_dir"; then
        
        create_metadata "$backup_dir"
        
        if verify_backup "$backup_dir"; then
            show_summary "$backup_dir"
            cleanup_old_backups
            log_success "Backup process completed successfully"
        else
            log_error "Backup verification failed"
            exit 1
        fi
    else
        log_error "Backup process failed"
        exit 1
    fi
}

# Run main function
main "$@"
