#!/bin/bash
# Immich Restore Script

set -euo pipefail

# Configuration
SCRIPT_NAME="$(basename "$0")"
IMMICH_DATA_PATH="{{ immich_data_path }}"
BACKUP_PATH="{{ immich_backup_path }}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/restore.log"
}

log_success() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/restore.log"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/restore.log"
}

log_error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$BACKUP_PATH/restore.log"
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    if ! command -v docker &> /dev/null; then
        missing+=("docker")
    fi
    
    if ! command -v tar &> /dev/null; then
        missing+=("tar")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        exit 1
    fi
}

# Stop Immich services
stop_immich() {
    log "Stopping Immich services..."
    
    if docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" down; then
        log_success "Immich services stopped"
    else
        log_warning "Failed to stop Immich services (may already be stopped)"
    fi
}

# Start Immich services
start_immich() {
    log "Starting Immich services..."
    
    if docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" up -d; then
        log_success "Immich services started"
        
        # Wait for services to be ready
        log "Waiting for services to be ready..."
        sleep 10
    else
        log_error "Failed to start Immich services"
        return 1
    fi
}

# Validate backup directory
validate_backup() {
    local backup_dir="$1"
    
    if [[ ! -d "$backup_dir" ]]; then
        log_error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    local required_files=(
        "database.sql.gz"
        "metadata.json"
    )
    
    local missing_files=0
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$backup_dir/$file" ]]; then
            log_error "Missing required file: $file"
            ((missing_files++))
        fi
    done
    
    if [[ $missing_files -gt 0 ]]; then
        log_error "Backup validation failed: $missing_files missing files"
        return 1
    fi
    
    log_success "Backup validation passed"
    return 0
}

# Show backup information
show_backup_info() {
    local backup_dir="$1"
    local metadata_file="$backup_dir/metadata.json"
    
    if [[ -f "$metadata_file" ]]; then
        log "Backup information:"
        
        if command -v jq &> /dev/null; then
            local backup_name
            backup_name=$(jq -r '.backup_name' "$metadata_file" 2>/dev/null || echo "unknown")
            local created_at
            created_at=$(jq -r '.created_at' "$metadata_file" 2>/dev/null || echo "unknown")
            local immich_version
            immich_version=$(jq -r '.immich_version' "$metadata_file" 2>/dev/null || echo "unknown")
            
            log "  Name: $backup_name"
            log "  Created: $created_at"
            log "  Immich version: $immich_version"
        else
            log "  Metadata file found (jq not available for detailed parsing)"
        fi
    else
        log_warning "No metadata file found"
    fi
    
    # Show backup size
    local total_size
    total_size=$(du -sh "$backup_dir" | cut -f1)
    log "  Total size: $total_size"
}

# Restore database
restore_database() {
    local backup_dir="$1"
    local db_backup_file="$backup_dir/database.sql.gz"
    
    log "Restoring database..."
    
    # Start database only
    log "Starting database service..."
    docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" up -d immich-database
    
    # Wait for database to be ready
    log "Waiting for database to be ready..."
    local retries=30
    while [[ $retries -gt 0 ]]; do
        if docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database pg_isready -U {{ immich_db_user }} -d {{ immich_db_name }} &>/dev/null; then
            break
        fi
        sleep 2
        ((retries--))
    done
    
    if [[ $retries -eq 0 ]]; then
        log_error "Database failed to become ready"
        return 1
    fi
    
    # Drop existing database
    log "Dropping existing database..."
    docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database psql -U {{ immich_db_user }} -c "DROP DATABASE IF EXISTS {{ immich_db_name }};"
    
    # Create new database
    log "Creating new database..."
    docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database psql -U {{ immich_db_user }} -c "CREATE DATABASE {{ immich_db_name }};"
    
    # Restore database
    log "Restoring database from backup..."
    if gunzip -c "$db_backup_file" | docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database psql -U {{ immich_db_user }} -d {{ immich_db_name }}; then
        log_success "Database restored successfully"
    else
        log_error "Database restore failed"
        return 1
    fi
    
    # Stop database
    docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" stop immich-database
}

# Restore application data
restore_app_data() {
    local backup_dir="$1"
    
    log "Restoring application data..."
    
    local data_backups=(
        "uploads.tar.gz:{{ immich_upload_path }}"
        "library.tar.gz:{{ immich_library_path }}"
        "thumbs.tar.gz:{{ immich_thumb_path }}"
        "profile.tar.gz:{{ immich_profile_path }}"
    )
    
    for backup_entry in "${data_backups[@]}"; do
        local backup_file="${backup_entry%:*}"
        local target_path="${backup_entry#*:}"
        
        if [[ -f "$backup_dir/$backup_file" ]]; then
            local path_name
            path_name=$(basename "$target_path")
            
            log "Restoring $path_name..."
            
            # Backup existing data
            if [[ -d "$target_path" && -n "$(ls -A "$target_path" 2>/dev/null)" ]]; then
                local backup_existing
                backup_existing="${target_path}.backup.$(date +%Y%m%d-%H%M%S)"
                log "Backing up existing $path_name to $backup_existing"
                mv "$target_path" "$backup_existing"
            fi
            
            # Create target directory
            mkdir -p "$target_path"
            
            # Extract backup
            if tar -xzf "$backup_dir/$backup_file" -C "$(dirname "$target_path)"; then
                log_success "$path_name restored successfully"
            else
                log_error "$path_name restore failed"
                return 1
            fi
        else
            log_warning "Backup file not found: $backup_file"
        fi
    done
}

# Restore configuration
restore_config() {
    local backup_dir="$1"
    local config_backup_file="$backup_dir/config.tar.gz"
    
    if [[ -f "$config_backup_file" ]]; then
        log "Restoring configuration..."
        
        # Backup existing configuration
        if [[ -f "$IMMICH_DATA_PATH/docker-compose.yml" ]]; then
            cp "$IMMICH_DATA_PATH/docker-compose.yml" "$IMMICH_DATA_PATH/docker-compose.yml.backup.$(date +%Y%m%d-%H%M%S)"
        fi
        
        if [[ -f "$IMMICH_DATA_PATH/.env" ]]; then
            cp "$IMMICH_DATA_PATH/.env" "$IMMICH_DATA_PATH/.env.backup.$(date +%Y%m%d-%H%M%S)"
        fi
        
        # Extract configuration
        if tar -xzf "$config_backup_file" -C "$IMMICH_DATA_PATH"; then
            log_success "Configuration restored successfully"
        else
            log_warning "Configuration restore failed"
        fi
    else
        log_warning "Configuration backup not found"
    fi
}

# Verify restore
verify_restore() {
    log "Verifying restore..."
    
    # Check if database is accessible
    if docker compose -f "$IMMICH_DATA_PATH/docker-compose.yml" exec -T immich-database psql -U {{ immich_db_user }} -d {{ immich_db_name }} -c "SELECT COUNT(*) FROM users;" &>/dev/null; then
        log_success "Database is accessible"
    else
        log_warning "Database verification failed"
    fi
    
    # Check if data directories exist
    local data_paths=(
        "{{ immich_upload_path }}"
        "{{ immich_library_path }}"
        "{{ immich_thumb_path }}"
        "{{ immich_profile_path }}"
    )
    
    for path in "${data_paths[@]}"; do
        if [[ -d "$path" ]]; then
            local file_count
            file_count=$(find "$path" -type f | wc -l)
            log "$(basename "$path"): $file_count files"
        else
            log_warning "$(basename "$path"): directory not found"
        fi
    done
}

# Show usage
show_usage() {
    echo "Usage: $0 [OPTIONS] BACKUP_NAME"
    echo ""
    echo "Options:"
    echo "  -h, --help          Show this help"
    echo "  -l, --list         List available backups"
    echo "  -i, --info NAME    Show backup information"
    echo "  --dry-run          Show what would be restored without doing it"
    echo ""
    echo "Arguments:"
    echo "  BACKUP_NAME        Name of backup to restore (e.g., immich-backup-20240101-120000)"
    echo ""
    echo "Environment:"
    echo "  IMMICH_DATA_PATH: $IMMICH_DATA_PATH"
    echo "  BACKUP_PATH: $BACKUP_PATH"
}

# List available backups
list_backups() {
    log "Available backups:"
    
    if [[ ! -d "$BACKUP_PATH" ]]; then
        log "No backup directory found"
        return 1
    fi
    
    find "$BACKUP_PATH" -maxdepth 1 -type d -name "immich-backup-*" -exec basename {} \; | sort
}

# Show backup information
show_backup_info_only() {
    local backup_name="$1"
    local backup_dir="$BACKUP_PATH/$backup_name"
    
    if ! validate_backup "$backup_dir"; then
        return 1
    fi
    
    show_backup_info "$backup_dir"
}

# Main execution
main() {
    local list_only=false
    local info_only=false
    local dry_run=false
    local backup_name=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -i|--info)
                info_only=true
                backup_name="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                backup_name="$1"
                shift
                ;;
        esac
    done
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root"
        exit 1
    fi
    
    # Check dependencies
    check_dependencies
    
    # Handle different modes
    if [[ "$list_only" == "true" ]]; then
        list_backups
        exit 0
    fi
    
    if [[ "$info_only" == "true" ]]; then
        if [[ -z "$backup_name" ]]; then
            log_error "Backup name required for info mode"
            show_usage
            exit 1
        fi
        show_backup_info_only "$backup_name"
        exit 0
    fi
    
    # Check backup name
    if [[ -z "$backup_name" ]]; then
        log_error "Backup name required"
        show_usage
        exit 1
    fi
    
    local backup_dir="$BACKUP_PATH/$backup_name"
    
    # Validate backup
    if ! validate_backup "$backup_dir"; then
        exit 1
    fi
    
    # Show backup information
    show_backup_info "$backup_dir"
    
    if [[ "$dry_run" == "true" ]]; then
        log "Dry run mode - no changes will be made"
        log "Would restore from: $backup_dir"
        exit 0
    fi
    
    # Confirm restore
    log ""
    log_warning "This will restore Immich from backup and may overwrite existing data!"
    log_warning "Make sure Immich is stopped before proceeding."
    echo ""
    read -p "Continue with restore? (y/N): " -n 1 -r
    echo ""
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "Restore cancelled"
        exit 0
    fi
    
    # Main restore process
    log "Starting Immich restore process"
    
    # Stop Immich services
    stop_immich
    
    # Restore components
    if restore_database "$backup_dir" && \
       restore_app_data "$backup_dir" && \
       restore_config "$backup_dir"; then
        
        log_success "Restore completed successfully"
        
        # Start Immich services
        start_immich
        
        # Verify restore
        verify_restore
        
        log ""
        log_success "Immich restore process completed"
        log "You can now access Immich at: http://localhost{{ immich_url_prefix }}/"
        
    else
        log_error "Restore process failed"
        exit 1
    fi
}

# Run main function
main "$@"
